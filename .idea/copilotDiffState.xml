<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/sweetapps/pocketchord/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/sweetapps/pocketchord/MainActivity.kt" />
              <option name="originalContent" value="package com.sweetapps.pocketchord&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.*&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import android.graphics.Color as AndroidColor&#10;import androidx.core.view.WindowCompat&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import com.sweetapps.pocketchord.ui.theme.PocketChordTheme&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.isFinite&#10;import androidx.lifecycle.lifecycleScope&#10;import android.net.Uri&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.compose.foundation.layout.FlowRow&#10;import android.media.ToneGenerator&#10;import android.media.AudioManager&#10;import kotlinx.coroutines.delay&#10;import android.media.AudioTrack&#10;import android.media.AudioAttributes&#10;import android.media.AudioFormat&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        // Ensure status bar background is white and icons are dark for readability at runtime&#10;        // Use WindowCompat/WindowInsetsControllerCompat for backward-compatible control&#10;        window.statusBarColor = AndroidColor.WHITE&#10;        val controller = WindowCompat.getInsetsController(window, window.decorView)&#10;        controller.isAppearanceLightStatusBars = true&#10;        // Optionally make navigation bar light as well&#10;        try {&#10;            controller.isAppearanceLightNavigationBars = true&#10;            window.navigationBarColor = AndroidColor.WHITE&#10;        } catch (_: Exception) {&#10;            // ignore on older platforms where this may not be supported&#10;        }&#10;        setContent {&#10;            PocketChordTheme {&#10;                val navController = rememberNavController()&#10;                Scaffold(&#10;                    bottomBar = { BottomNavigationBar(navController) },&#10;                    containerColor = Color.White&#10;                ) { innerPadding -&gt;&#10;                    NavHost(&#10;                        navController = navController,&#10;                        startDestination = &quot;home&quot;,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    ) {&#10;                        composable(&quot;home&quot;) {&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: home&quot;)&#10;                            MainScreen(navController)&#10;                        }&#10;                        composable(&quot;metronome&quot;) { com.sweetapps.pocketchord.ui.screens.MetronomeProScreen() }&#10;                        composable(&quot;tuner&quot;) { com.sweetapps.pocketchord.ui.screens.GuitarTunerScreen() }&#10;                        composable(&quot;search&quot;) {&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: search&quot;)&#10;                            SearchResultScreen()&#10;                        }&#10;                        composable(&quot;search_chord&quot;) {&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: search_chord&quot;)&#10;                            SearchChordScreen()&#10;                        }&#10;                        // Declare argument type explicitly; we'll decode on read&#10;                        composable(&#10;                            route = &quot;chord_list/{root}&quot;,&#10;                            arguments = listOf(navArgument(&quot;root&quot;) { type = NavType.StringType })&#10;                        ) { backStackEntry -&gt;&#10;                            val encoded = backStackEntry.arguments?.getString(&quot;root&quot;)&#10;                            val root = encoded?.let { Uri.decode(it) } ?: &quot;C&quot;&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: chord_list/$root (encoded=$encoded)&quot;)&#10;                            ChordListScreen(navController = navController, root = root, onBack = { navController.popBackStack() })&#10;                        }&#10;                        // Optional settings screen remains, but without any seeding controls&#10;                        composable(&quot;settings&quot;) { BasicSettingsScreen() }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;&#10;        // On-app-update reseed only&#10;        lifecycleScope.launchWhenCreated {&#10;             try { com.sweetapps.pocketchord.data.ensureOrReseedOnAppUpdate(this@MainActivity) } catch (_: Exception) {}&#10;         }&#10;     }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(navController: NavHostController) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 24.dp)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;        TopBar()&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        Text(&#10;            text = &quot;코드를 선택하세요&quot;,&#10;            fontSize = 28.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color(0xFF31455A)&#10;        )&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        ChordGrid(navController)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TopBar() {&#10;    Row(verticalAlignment = Alignment.CenterVertically) {&#10;        Icon(&#10;            painter = painterResource(id = android.R.drawable.ic_media_play), // 임시 아이콘&#10;            contentDescription = null,&#10;            tint = Color(0xFF31455A),&#10;            modifier = Modifier.size(28.dp)&#10;        )&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;        Text(&#10;            text = &quot;PocketChord&quot;,&#10;            fontWeight = FontWeight.Bold,&#10;            fontSize = 22.sp,&#10;            color = Color(0xFF31455A)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChordGrid(navController: NavHostController) {&#10;    val chords = listOf(&#10;        &quot;C&quot;, &quot;C#-Db&quot;, &quot;D&quot;, &quot;D#-Eb&quot;,&#10;        &quot;E&quot;, &quot;F&quot;, &quot;F#-Gb&quot;, &quot;G&quot;,&#10;        &quot;G#-Ab&quot;, &quot;A&quot;, &quot;A#-Bb&quot;, &quot;B&quot;&#10;    )&#10;&#10;    // Map display names to root keys used in JSON&#10;    fun getRoot(displayName: String): String {&#10;        return when (displayName) {&#10;            &quot;C#-Db&quot; -&gt; &quot;C#&quot;&#10;            &quot;D#-Eb&quot; -&gt; &quot;D#&quot;&#10;            &quot;F#-Gb&quot; -&gt; &quot;F#&quot;&#10;            &quot;G#-Ab&quot; -&gt; &quot;G#&quot;&#10;            &quot;A#-Bb&quot; -&gt; &quot;A#&quot;&#10;            else -&gt; displayName&#10;        }&#10;    }&#10;&#10;    Column {&#10;        chords.chunked(3).forEach { rowList -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                rowList.forEach { chord -&gt;&#10;                    ChordButton(&#10;                        chord = chord,&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .clickable {&#10;                                val root = getRoot(chord)&#10;                                // encode to keep special characters (e.g., '#') safe in route path&#10;                                val route = &quot;chord_list/${Uri.encode(root)}&quot;&#10;                                Log.d(&quot;NavDebug&quot;, &quot;Click: navigating to ${route} from grid (chord=${chord}, root=${root})&quot;)&#10;                                navController.navigate(route)&#10;                            }&#10;                    )&#10;                }&#10;                // fill remaining columns with spacers if row has less than 3 items&#10;                if (rowList.size &lt; 3) {&#10;                    repeat(3 - rowList.size) { Spacer(modifier = Modifier.weight(1f)) }&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(20.dp))&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChordButton(chord: String, modifier: Modifier = Modifier) {&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .background(Color.White, RoundedCornerShape(20.dp))&#10;            .padding(8.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = chord,&#10;            fontWeight = FontWeight.Bold,&#10;            fontSize = 22.sp,&#10;            color = Color(0xFF31455A)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BottomNavigationBar(navController: NavHostController) {&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    NavigationBar(containerColor = Color.Transparent) {&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Home, contentDescription = &quot;홈&quot;) },&#10;            label = { Text(&quot;홈&quot;) },&#10;            selected = currentRoute == &quot;home&quot;,&#10;            onClick = { navController.navigate(&quot;home&quot;) }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Alarm, contentDescription = &quot;메트로놈&quot;) },&#10;            label = { Text(&quot;메트로놈&quot;) },&#10;            selected = currentRoute == &quot;metronome&quot;,&#10;            onClick = { navController.navigate(&quot;metronome&quot;) }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Equalizer, contentDescription = &quot;튜너&quot;) },&#10;            label = { Text(&quot;튜너&quot;) },&#10;            selected = currentRoute == &quot;tuner&quot;,&#10;            onClick = { navController.navigate(&quot;tuner&quot;) }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Star, contentDescription = &quot;즐겨찾기&quot;) },&#10;            label = { Text(&quot;즐겨찾기&quot;) },&#10;            selected = currentRoute == &quot;favorites&quot;, // 아직 미구현&#10;            onClick = { /* TODO: 즐겨찾기 구현 */ }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Settings, contentDescription = &quot;설정&quot;) },&#10;            label = { Text(&quot;설정&quot;) },&#10;            selected = currentRoute == &quot;settings&quot;,&#10;            onClick = { navController.navigate(&quot;settings&quot;) }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SearchResultScreen() {&#10;    val chordName = &quot;Cmaj7&quot;&#10;    val tags = listOf(&quot;C&quot;, &quot;Major 7&quot;, &quot;b5&quot;)&#10;    val codeCards = listOf(&#10;        FretDiagramData(&quot;TYARRRI&quot;, listOf(1, 3, 5, 7, 8, 0), fingers = listOf(0,2,3,0,1,0)),&#10;        FretDiagramData(&quot;AOTTTOURAL&quot;, listOf(2, 4, 6, 8, 10, 0), fingers = listOf(0,1,3,4,0,0))&#10;    )&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;            .padding(horizontal = 16.dp)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                contentDescription = &quot;뒤로가기&quot;,&#10;                tint = Color(0xFF31455A),&#10;                modifier = Modifier.size(28.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(&#10;                text = &quot;검색 결과: $chordName&quot;,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 20.sp,&#10;                color = Color(0xFF31455A)&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            tags.forEach {&#10;                AssistChip(&#10;                    onClick = {},&#10;                    label = { Text(it, color = Color(0xFF31455A), fontWeight = FontWeight.Bold) },&#10;                    colors = AssistChipDefaults.assistChipColors(&#10;                        containerColor = Color(0xFFE3F0FF)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            // 코드 카드 UI는 제거됨. 간단히 코드 이름과 다이어그램 링크(예시)를 나열합니다.&#10;            codeCards.forEach { data -&gt;&#10;                Row(modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp), verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(text = data.name, fontWeight = FontWeight.Bold, fontSize = 16.sp, modifier = Modifier.weight(1f))&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    // 간단한 소형 다이어그램을 우측에 표시&#10;                    FretDiagramImage()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SearchChordScreen() {&#10;    val types = listOf(&quot;Major&quot;, &quot;minor&quot;, &quot;dim&quot;, &quot;aug&quot;)&#10;    val tensions = listOf(&quot;7&quot;, &quot;M7&quot;, &quot;6&quot;, &quot;sus4&quot;, &quot;9&quot;, &quot;11&quot;, &quot;13&quot;)&#10;    val options = listOf(&quot;add9&quot;, &quot;b5&quot;, &quot;#5&quot;, &quot;b9&quot;)&#10;    val selectedRoot = &quot;C&quot;&#10;    val selectedType = &quot;Major&quot;&#10;    val selectedTension = &quot;M7&quot;&#10;    val selectedOptions = listOf(&quot;add9&quot;)&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;    ) {&#10;        // 상단 바&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth().padding(top = 16.dp, bottom = 8.dp, start = 8.dp, end = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = { /* TODO: 뒤로가기 */ }) {&#10;                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;뒤로가기&quot;, tint = Color(0xFF31455A))&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Text(&quot;코드 검색&quot;, fontWeight = FontWeight.Bold, fontSize = 18.sp, color = Color(0xFF31455A))&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Text(&quot;Reset&quot;, color = Color(0xFF00C6A2), fontWeight = FontWeight.Bold, modifier = Modifier.clickable { /* TODO: 리셋 */ })&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 코드명 및 설명&#10;        Column(modifier = Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {&#10;            Text(&quot;Cmaj7(add9)&quot;, fontWeight = FontWeight.Bold, fontSize = 32.sp, color = Color(0xFF31455A))&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&quot;아래 버튼을 눌러 코드를 조합해 보세요.&quot;, fontSize = 16.sp, color = Color(0xFF8CA0B3))&#10;        }&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;        // 루트 노트&#10;        SectionTitle(&quot;루트 노트 (Root Note)&quot;)&#10;        OutlinedButton(&#10;            onClick = {},&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = ButtonDefaults.outlinedButtonColors(containerColor = Color(0xFF00C6A2), contentColor = Color.White),&#10;            modifier = Modifier.fillMaxWidth().height(48.dp).padding(vertical = 8.dp, horizontal = 8.dp)&#10;        ) {&#10;            Text(selectedRoot, fontWeight = FontWeight.Bold, fontSize = 20.sp)&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 타입&#10;        SectionTitle(&quot;타입 (Type)&quot;)&#10;        Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            types.forEach {&#10;                OutlinedButton(&#10;                    onClick = {},&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        containerColor = if (it == selectedType) Color(0xFF00C6A2) else Color.White,&#10;                        contentColor = if (it == selectedType) Color.White else Color(0xFF31455A)&#10;                    ),&#10;                    modifier = Modifier.weight(1f).height(40.dp)&#10;                ) {&#10;                    Text(it, fontWeight = FontWeight.Bold)&#10;                }&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 텐션&#10;        SectionTitle(&quot;텐션 (Tensions)&quot;)&#10;        Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            tensions.forEach {&#10;                OutlinedButton(&#10;                    onClick = {},&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        containerColor = if (it == selectedTension) Color(0xFF00C6A2) else Color.White,&#10;                        contentColor = if (it == selectedTension) Color.White else Color(0xFF31455A)&#10;                    ),&#10;                    modifier = Modifier.weight(1f).height(40.dp)&#10;                ) {&#10;                    Text(it, fontWeight = FontWeight.Bold)&#10;                }&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 추가 옵션&#10;        SectionTitle(&quot;추가 옵션 (Options)&quot;)&#10;        Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            options.forEach {&#10;                OutlinedButton(&#10;                    onClick = {},&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        containerColor = if (selectedOptions.contains(it)) Color(0xFF00C6A2) else Color.White,&#10;                        contentColor = if (selectedOptions.contains(it)) Color.White else Color(0xFF31455A)&#10;                    ),&#10;                    modifier = Modifier.weight(1f).height(40.dp)&#10;                ) {&#10;                    Text(it, fontWeight = FontWeight.Bold)&#10;                }&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.weight(1f))&#10;        // 하단 코드 찾기 버튼&#10;        Box(modifier = Modifier.fillMaxWidth().padding(16.dp), contentAlignment = Alignment.Center) {&#10;            Button(&#10;                onClick = { /* TODO: 코드 찾기 */ },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFFFA800)),&#10;                modifier = Modifier.fillMaxWidth().height(56.dp)&#10;            ) {&#10;                Icon(Icons.Filled.Search, contentDescription = null, tint = Color.White)&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;코드 찾기&quot;, fontWeight = FontWeight.Bold, fontSize = 20.sp, color = Color.White)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SectionTitle(title: String) {&#10;    Text(title, fontWeight = FontWeight.Bold, fontSize = 16.sp, color = Color(0xFF31455A), modifier = Modifier.padding(start = 8.dp, bottom = 8.dp))&#10;}&#10;&#10;// 코드 다이어그램 데이터 예시&#10;// positions: stringCount 길이, -1=뮤트, 0=open, &gt;0=프렛번호&#10;// fingers: 동일 길이의 리스트, 0=표시안함, &gt;0=핑거링 숫자&#10;data class FretDiagramData(val name: String, val positions: List&lt;Int&gt;, val fingers: List&lt;Int&gt;? = null)&#10;&#10;// helper: parse CSV like &quot;-1,3,2,0,1,0&quot; into internal positions List&lt;Int&gt; index0=lowest string&#10;fun parseCsvToPositions(csv: String): List&lt;Int&gt; {&#10;    // Parse CSV into ints and return as-is. Storage order in DB/seed is 6→1 and UI expects the same.&#10;    return csv.split(&quot;,&quot;).mapNotNull { it.trim().toIntOrNull() }&#10;}&#10;&#10;// helper: parse barresJson (seed/DB) into ExplicitBarre list&#10;fun parseBarresJson(json: String?): List&lt;ExplicitBarre&gt;? {&#10;    if (json.isNullOrBlank()) return null&#10;    return try {&#10;        val arr = org.json.JSONArray(json)&#10;        val list = mutableListOf&lt;ExplicitBarre&gt;()&#10;        for (i in 0 until arr.length()) {&#10;            val o = arr.getJSONObject(i)&#10;            val fret = o.optInt(&quot;fret&quot;, 0)&#10;            val finger = o.optInt(&quot;finger&quot;, 0)&#10;            var fromS = o.optInt(&quot;fromString&quot;, 0)&#10;            var toS = o.optInt(&quot;toString&quot;, 0)&#10;            if (fret &gt; 0 &amp;&amp; finger &gt; 0 &amp;&amp; fromS in 1..6 &amp;&amp; toS in 1..6) {&#10;                if (fromS &gt; toS) { val tmp = fromS; fromS = toS; toS = tmp }&#10;                list.add(ExplicitBarre(fret, finger, fromS, toS))&#10;            }&#10;        }&#10;        if (list.isEmpty()) null else list&#10;    } catch (_: Throwable) { null }&#10;}&#10;&#10;// Build grouped sections for a given root according to requested order&#10;private data class ChordSection(val title: String, val items: List&lt;com.sweetapps.pocketchord.data.ChordWithVariants&gt;)&#10;private fun buildChordSectionsForRoot(root: String, all: List&lt;com.sweetapps.pocketchord.data.ChordWithVariants&gt;): List&lt;ChordSection&gt; {&#10;    // Templates expressed for root C; replace leading 'C' with the actual root&#10;    val groups = listOf(&#10;        &quot;Major&quot; to listOf(&quot;C&quot;, &quot;Cadd9&quot;, &quot;CM7&quot;, &quot;CM7(9)&quot;, &quot;C6&quot;, &quot;C6(9)&quot;),&#10;        &quot;minor&quot; to listOf(&quot;Cm&quot;, &quot;Cm7&quot;, &quot;Cm7(9)&quot;, &quot;Cm7(11)&quot;, &quot;Cm6&quot;, &quot;CmM7&quot;, &quot;Cm7(b5)&quot;, &quot;Cdim7&quot;),&#10;        &quot;7th&quot; to listOf(&quot;C7&quot;, &quot;C7(9)&quot;, &quot;C7(13)&quot;, &quot;C7(b5)&quot;, &quot;Csus4&quot;, &quot;C7sus4&quot;, &quot;Caug&quot;, &quot;C7aug&quot;)&#10;    )&#10;    fun toName(template: String): String = if (template.startsWith(&quot;C&quot;)) root + template.removePrefix(&quot;C&quot;) else template&#10;    val byName = all.associateBy { it.chord.name }&#10;    val used = mutableSetOf&lt;Long&gt;()&#10;    val sections = mutableListOf&lt;ChordSection&gt;()&#10;    for ((title, templates) in groups) {&#10;        val names = templates.map(::toName)&#10;        val items = names.mapNotNull { nm -&gt;&#10;            val m = byName[nm]&#10;            if (m != null) {&#10;                used.add(m.chord.id); m&#10;            } else null&#10;        }&#10;        if (items.isNotEmpty()) sections.add(ChordSection(title, items))&#10;    }&#10;    // Remaining chords not covered above → 기타(이름순)&#10;    val others = all.filter { used.contains(it.chord.id).not() }.sortedBy { it.chord.name }&#10;    if (others.isNotEmpty()) sections.add(ChordSection(&quot;기타&quot;, others))&#10;    return sections&#10;}&#10;&#10;@Composable&#10;fun ChordListScreen(&#10;    navController: NavHostController,&#10;    root: String,&#10;    onBack: () -&gt; Unit = {},&#10;    uiParams: DiagramUiParams = defaultDiagramUiParams()&#10;) {&#10;    val context = LocalContext.current&#10;    val db = com.sweetapps.pocketchord.data.AppDatabase.getInstance(context)&#10;    val chordFlow = db.chordDao().getChordsByRoot(root)&#10;    val chordWithVariants by chordFlow.collectAsState(initial = emptyList())&#10;    var isSeeding by remember { mutableStateOf(false) }&#10;&#10;    val perRootAsset = remember(root) { com.sweetapps.pocketchord.data.seedAssetFileNameForRoot(root) }&#10;&#10;    // ensure missing variants for this root (insert-only)&#10;    LaunchedEffect(root) {&#10;        try {&#10;            isSeeding = true&#10;            // 1) per-root 파일 우선 시딩 (프록시 형식 지원)&#10;            com.sweetapps.pocketchord.data.ensureChordsForRoot(context, root, perRootAsset)&#10;            // 2) 안전 폴백: 통합 파일에서도 시딩 (중복은 내부에서 방지)&#10;            com.sweetapps.pocketchord.data.ensureChordsForRoot(context, root)&#10;        } catch (t: Throwable) {&#10;            android.util.Log.w(&quot;ChordListScreen&quot;, &quot;ensureChordsForRoot failed&quot;, t)&#10;        } finally {&#10;            isSeeding = false&#10;        }&#10;    }&#10;&#10;    // 필터 상태: 단일 선택, null이면 전체 표시&#10;    var selectedFilter by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val availableFilters = listOf(&quot;Major&quot;, &quot;minor&quot;, &quot;7th&quot;)&#10;&#10;    // 섹션 구성 및 필터 적용&#10;    val allSections = remember(chordWithVariants, root) { buildChordSectionsForRoot(root, chordWithVariants) }&#10;    val sectionsToShow = remember(allSections, selectedFilter) {&#10;        if (selectedFilter == null) allSections else allSections.filter { it.title == selectedFilter }&#10;    }&#10;&#10;    Column(modifier = Modifier&#10;        .fillMaxSize()&#10;        .background(Color.White)&#10;    ) {&#10;        if (isSeeding) {&#10;            // simple loader overlay&#10;            Box(modifier = Modifier.fillMaxWidth().padding(12.dp), contentAlignment = Alignment.Center) {&#10;                CircularProgressIndicator()&#10;            }&#10;        }&#10;        // Top app bar with back button&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .background(Color.White)&#10;                .padding(start = 12.dp, top = 8.dp, bottom = 8.dp, end = 12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = { onBack() }) {&#10;                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;뒤로가기&quot;, tint = Color(0xFF31455A))&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(text = &quot;$root 코드&quot;, fontWeight = FontWeight.Bold, fontSize = 20.sp, color = Color(0xFF31455A))&#10;        }&#10;        // visual separation between top title and content — darker gray for better contrast&#10;        HorizontalDivider(color = Color(0xFFBDBDBD), thickness = 1.dp)&#10;&#10;        // 필터 칩(단일 선택 / 토글 해제)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .horizontalScroll(rememberScrollState())&#10;                .padding(start = 12.dp, end = 12.dp, top = 8.dp)&#10;        ) {&#10;            availableFilters.forEach { f -&gt;&#10;                val selected = selectedFilter == f&#10;                FilterChip(&#10;                    selected = selected,&#10;                    onClick = { selectedFilter = if (selected) null else f },&#10;                    label = {&#10;                        Text(&#10;                            text = f,&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                    },&#10;                    trailingIcon = if (selected) {&#10;                        { Icon(Icons.Filled.Close, contentDescription = &quot;해제&quot;, tint = Color.White) }&#10;                    } else null,&#10;                    shape = RoundedCornerShape(22.dp),&#10;                    border = null,&#10;                    colors = FilterChipDefaults.filterChipColors(&#10;                        containerColor = Color(0xFFF1F3F4),&#10;                        labelColor = Color(0xFF1F1F1F),&#10;                        selectedContainerColor = Color(0xFF1F1F1F),&#10;                        selectedLabelColor = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .height(40.dp)&#10;                        .padding(end = 10.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        // 총 개수(필터 적용 반영)&#10;        val totalVariants = sectionsToShow.sumOf { section -&gt; section.items.sumOf { it.variants.size } }&#10;        Text(text = &quot;총 ${totalVariants}개&quot;, fontWeight = FontWeight.Bold, fontSize = 16.sp, modifier = Modifier.padding(start = 16.dp))&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // 섹션별 리스트 (필터 반영)&#10;        LazyColumn(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentPadding = PaddingValues(vertical = 24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(DEFAULT_LIST_ITEM_SPACING_DP)&#10;        ) {&#10;            sectionsToShow.forEach { section -&gt;&#10;                item(key = &quot;header_${section.title}&quot;) {&#10;                    Text(&#10;                        text = section.title,&#10;                        fontWeight = FontWeight.ExtraBold,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF31455A),&#10;                        modifier = Modifier.padding(start = 16.dp, bottom = 6.dp, top = 8.dp)&#10;                    )&#10;                }&#10;                // Show every variant as an individual row so chords with multiple shapes (e.g., C) appear multiple times&#10;                items(&#10;                    items = section.items.flatMap { cwv -&gt; cwv.variants.map { v -&gt; cwv to v } },&#10;                    key = { pair -&gt; pair.second.id }&#10;                ) { pair -&gt;&#10;                    val cwv = pair.first&#10;                    val variant = pair.second&#10;                    val chordName = cwv.chord.name&#10;                    val positions = variant.positionsCsv.let { parseCsvToPositions(it) }&#10;                    val fingers = variant.fingersCsv?.let { parseCsvToPositions(it) } ?: List(6) { 0 }&#10;                    // debug log&#10;                    try {&#10;                        Log.d(&quot;ChordDiag&quot;, &quot;chord=${chordName} csvPositions=${variant.positionsCsv} parsedPositions=${positions} csvFingers=${variant.fingersCsv} parsedFingers=${fingers}&quot;)&#10;                    } catch (_: Exception) {}&#10;&#10;                    val desiredDiagramWidth = uiParams.diagramMaxWidthDp ?: 220.dp&#10;                    val diagramHeightForList = uiParams.diagramHeightDp ?: uiParams.diagramMinHeightDp&#10;                    val itemHeight = maxOf(uiParams.nameBoxSizeDp, diagramHeightForList)&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(itemHeight)&#10;                            .padding(horizontal = 12.dp, vertical = 8.dp),&#10;                        verticalAlignment = Alignment.Top&#10;                    ) {&#10;                        if (uiParams.diagramAnchor == DiagramAnchor.Left) {&#10;                            Box(modifier = Modifier.width(desiredDiagramWidth).height(diagramHeightForList)) {&#10;                                val explicitBarres = parseBarresJson(variant.barresJson)&#10;                                FretboardDiagramOnly(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    uiParams = uiParams,&#10;                                    positions = positions,&#10;                                    fingers = fingers,&#10;                                    firstFretIsNut = variant.firstFretIsNut,&#10;                                    invertStrings = false,&#10;                                    explicitBarres = explicitBarres&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.width(16.dp))&#10;                            Box(modifier = Modifier.size(uiParams.nameBoxSizeDp).background(DEFAULT_NAME_BOX_COLOR, shape = RoundedCornerShape(8.dp)), contentAlignment = Alignment.Center) {&#10;                                val chordFontSize = (uiParams.nameBoxSizeDp.value * uiParams.nameBoxFontScale).sp&#10;                                Text(text = chordName, color = Color.White, fontWeight = FontWeight.Bold, fontSize = chordFontSize)&#10;                            }&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;                        } else {&#10;                            Box(modifier = Modifier.size(uiParams.nameBoxSizeDp).background(DEFAULT_NAME_BOX_COLOR, shape = RoundedCornerShape(8.dp)), contentAlignment = Alignment.Center) {&#10;                                val chordFontSize = (uiParams.nameBoxSizeDp.value * uiParams.nameBoxFontScale).sp&#10;                                Text(text = chordName, color = Color.White, fontWeight = FontWeight.Bold, fontSize = chordFontSize)&#10;                            }&#10;                            Spacer(modifier = Modifier.width(16.dp))&#10;                            Box(modifier = Modifier.width(desiredDiagramWidth).height(diagramHeightForList)) {&#10;                                val explicitBarres = parseBarresJson(variant.barresJson)&#10;                                FretboardDiagramOnly(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    uiParams = uiParams,&#10;                                    positions = positions,&#10;                                    fingers = fingers,&#10;                                    firstFretIsNut = variant.firstFretIsNut,&#10;                                    invertStrings = false,&#10;                                    explicitBarres = explicitBarres&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;         }&#10;     }&#10;}&#10;&#10;@Composable&#10;fun FretboardCard(&#10;    chordName: String,&#10;    modifier: Modifier = Modifier,&#10;    uiParams: DiagramUiParams = defaultDiagramUiParams(), // centralized UI params&#10;    fretLabelProvider: ((Int) -&gt; String?)? = null&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp, horizontal = 4.dp), // 카드 외부 여백 약간 증가&#10;        shape = RoundedCornerShape(6.dp), // 더 둥글게&#10;        colors = CardDefaults.cardColors(containerColor = DEFAULT_CARD_BACKGROUND_COLOR),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)&#10;    ) {&#10;        // 카드 높이에 따라 다이어그램 크기를 계산하려면 BoxWithConstraints를 사용&#10;        BoxWithConstraints(modifier = Modifier.fillMaxWidth()) {&#10;            // BoxWithConstraints 범위에서 카드/다이어그램 크기 계산&#10;            val measuredCardHeight = this.maxHeight&#10;            val defaultCardHeight = 140.dp&#10;            // Use uiParams.cardHeightDp as authoritative when provided so Preview and runtime compute identically&#10;            val effectiveCardHeight = uiParams.cardHeightDp ?: if (measuredCardHeight.isFinite) measuredCardHeight else defaultCardHeight&#10;            // allow fixed diagram height via uiParams; otherwise derive from card height but respect min height&#10;            val diagramHeight = uiParams.diagramHeightDp ?: (effectiveCardHeight - 20.dp).coerceAtLeast(uiParams.diagramMinHeightDp)&#10;&#10;            // 카드 내부 상단에 여백을 위한 Spacer 추가&#10;            Column(modifier = Modifier.fillMaxWidth()) {&#10;                Spacer(modifier = Modifier.height(5.dp))&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(effectiveCardHeight)&#10;                        .padding(start = 8.dp, top = 8.dp, end = 0.dp, bottom = 8.dp),&#10;                     verticalAlignment = Alignment.Top&#10;                  ) {&#10;                    // collect sample DB-style positions &amp; fingers&#10;                    val dbPositionsForC = mapOf(1 to 0, 2 to 1, 3 to 0, 4 to 2, 5 to 3, 6 to -1)&#10;                    val dbFingersForC = mapOf(1 to 0, 2 to 1, 3 to 0, 4 to 2, 5 to 3, 6 to 0)&#10;                    val positionsForC = dbMapToInternalPositions(dbPositionsForC, stringCount = 6, defaultFret = -1)&#10;                    val fingersForC = dbMapToInternalPositions(dbFingersForC, stringCount = 6, defaultFret = 0)&#10;&#10;                    // reserved space used to compute total inner width (text area + gap). Do not include Row padding here.&#10;                    val textAreaWidth = 32.dp&#10;                    val gapBetween = 8.dp&#10;                    val reserved = textAreaWidth + gapBetween&#10;&#10;                    // compute desired (diagram) width from height-based calculation and configured max&#10;                    val heightBasedWidth = measuredCardHeight * (140f / 96f)&#10;                    val desiredWidth = uiParams.diagramMaxWidthDp?.let { mw -&gt; if (heightBasedWidth &gt; mw) mw else heightBasedWidth } ?: heightBasedWidth&#10;&#10;                    // total inner width that contains text + gap + diagram + right inset&#10;                    val innerTotal = reserved + desiredWidth + uiParams.diagramRightInsetDp&#10;&#10;                    // Align the fixed-width inner row to the card's end so the trailing inset becomes the gap to the card edge&#10;                    Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.CenterEnd) {&#10;                        Row(modifier = Modifier.width(innerTotal).height(effectiveCardHeight), verticalAlignment = Alignment.Top) {&#10;                            // chord name (fixed width)&#10;                            Text(text = chordName, fontWeight = FontWeight.Bold, fontSize = 26.sp, color = Color.Black, modifier = Modifier.width(textAreaWidth).padding(start = 4.dp))&#10;                            Spacer(modifier = Modifier.width(gapBetween))&#10;                            Box(modifier = Modifier.width(desiredWidth).height(diagramHeight)) {&#10;                                if (chordName == &quot;C&quot;) {&#10;                                    FretboardDiagramOnly(modifier = Modifier.fillMaxSize(), uiParams = uiParams, positions = positionsForC, fingers = fingersForC, firstFretIsNut = true, fretLabelProvider = fretLabelProvider, invertStrings = false)&#10;                                } else {&#10;                                    // default empty/mute positions for non-sample chords in preview&#10;                                    val defaultPositions = List(6) { -1 }&#10;                                    val defaultFingers = List(6) { 0 }&#10;                                    FretboardDiagramOnly(modifier = Modifier.fillMaxSize(), uiParams = uiParams, positions = defaultPositions, fingers = defaultFingers, firstFretIsNut = true, invertStrings = false)&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.width(uiParams.diagramRightInsetDp))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BasicSettingsScreen() {&#10;    // Minimal settings placeholder — removed manual seeding and toggles&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;        Text(text = &quot;설정&quot;, fontSize = 20.sp, fontWeight = FontWeight.Bold)&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;        Text(text = &quot;앱 업데이트 시 코드 데이터가 자동으로 동기화됩니다.&quot;)&#10;    }&#10;}&#10;&#10;// --- New screens ---&#10;@Composable&#10;fun MetronomeScreen() {&#10;    var bpm by remember { mutableStateOf(100f) }&#10;    var playing by remember { mutableStateOf(false) }&#10;    var beatInBar by remember { mutableStateOf(4) }&#10;    var currentBeat by remember { mutableStateOf(1) }&#10;&#10;    // Tone generator for click sounds&#10;    val toneGen = remember { ToneGenerator(AudioManager.STREAM_MUSIC, 80) }&#10;    DisposableEffect(Unit) {&#10;        onDispose { try { toneGen.release() } catch (_: Throwable) {} }&#10;    }&#10;&#10;    LaunchedEffect(playing, bpm, beatInBar) {&#10;        currentBeat = 1&#10;        if (playing) {&#10;            val intervalMs = (60_000f / bpm).toLong().coerceAtLeast(40L)&#10;            while (playing) {&#10;                // accent first beat&#10;                val tone = if (currentBeat == 1) ToneGenerator.TONE_PROP_BEEP2 else ToneGenerator.TONE_PROP_BEEP&#10;                try { toneGen.startTone(tone, 60) } catch (_: Throwable) {}&#10;                currentBeat = if (currentBeat &gt;= beatInBar) 1 else currentBeat + 1&#10;                delay(intervalMs)&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {&#10;        Text(&quot;메트로놈&quot;, fontWeight = FontWeight.Bold, fontSize = 22.sp)&#10;        Spacer(Modifier.height(16.dp))&#10;        // Beat indicators&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            repeat(beatInBar) { idx -&gt;&#10;                val active = playing &amp;&amp; (idx + 1) == currentBeat&#10;                Box(modifier = Modifier.size(18.dp).background(if (active) Color(0xFFFF6F00) else Color(0xFFB0BEC5), RoundedCornerShape(50)))&#10;            }&#10;        }&#10;        Spacer(Modifier.height(16.dp))&#10;        Text(&quot;BPM: ${bpm.toInt()}&quot;)&#10;        Slider(&#10;            value = bpm,&#10;            onValueChange = { bpm = it.coerceIn(40f, 240f) },&#10;            valueRange = 40f..240f&#10;        )&#10;        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            OutlinedButton(onClick = { bpm = (bpm - 1).coerceAtLeast(40f) }) { Text(&quot;-1&quot;) }&#10;            OutlinedButton(onClick = { bpm = (bpm + 1).coerceAtMost(240f) }) { Text(&quot;+1&quot;) }&#10;            OutlinedButton(onClick = { bpm = (bpm - 5).coerceAtLeast(40f) }) { Text(&quot;-5&quot;) }&#10;            OutlinedButton(onClick = { bpm = (bpm + 5).coerceAtMost(240f) }) { Text(&quot;+5&quot;) }&#10;        }&#10;        Spacer(Modifier.height(12.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&quot;박자 수: &quot;)&#10;            Row {&#10;                listOf(2,3,4,6).forEach { n -&gt;&#10;                    FilterChip(&#10;                        selected = beatInBar == n,&#10;                        onClick = { beatInBar = n; currentBeat = 1 },&#10;                        label = { Text(&quot;${n}&quot;) },&#10;                        modifier = Modifier.padding(horizontal = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        Spacer(Modifier.height(24.dp))&#10;        Button(onClick = { playing = !playing }, colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (playing) Color(0xFFD32F2F) else Color(0xFF00C853)&#10;        )) {&#10;            Icon(if (playing) Icons.Filled.Pause else Icons.Filled.PlayArrow, contentDescription = null)&#10;            Spacer(Modifier.width(6.dp))&#10;            Text(if (playing) &quot;정지&quot; else &quot;시작&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TunerScreen() {&#10;    // Standard guitar open-string reference tones&#10;    val strings = listOf(&#10;        &quot;E(6) 82.41Hz&quot; to 82.41,&#10;        &quot;A(5) 110Hz&quot; to 110.0,&#10;        &quot;D(4) 146.83Hz&quot; to 146.83,&#10;        &quot;G(3) 196.00Hz&quot; to 196.0,&#10;        &quot;B(2) 246.94Hz&quot; to 246.94,&#10;        &quot;E(1) 329.63Hz&quot; to 329.63&#10;    )&#10;    var selected by remember { mutableStateOf(strings[5]) }&#10;    var track by remember { mutableStateOf&lt;AudioTrack?&gt;(null) }&#10;    var isPlaying by remember { mutableStateOf(false) }&#10;&#10;    fun stop() {&#10;        try { track?.stop() } catch (_: Throwable) {}&#10;        try { track?.release() } catch (_: Throwable) {}&#10;        track = null&#10;        isPlaying = false&#10;    }&#10;&#10;    DisposableEffect(Unit) { onDispose { stop() } }&#10;&#10;    fun createLoopingTone(freqHz: Double): AudioTrack? {&#10;        val sampleRate = 44_100&#10;        val durationSec = 1.0 // short but looped&#10;        val frameCount = (sampleRate * durationSec).toInt()&#10;        val buffer = ShortArray(frameCount) { i -&gt;&#10;            val t = i / sampleRate.toDouble()&#10;            val v = kotlin.math.sin(2.0 * Math.PI * freqHz * t)&#10;            (v * Short.MAX_VALUE).toInt().coerceIn(Short.MIN_VALUE.toInt(), Short.MAX_VALUE.toInt()).toShort()&#10;        }&#10;        return try {&#10;            val attrs = AudioAttributes.Builder()&#10;                .setUsage(AudioAttributes.USAGE_MEDIA)&#10;                .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)&#10;                .build()&#10;            val format = AudioFormat.Builder()&#10;                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)&#10;                .setSampleRate(sampleRate)&#10;                .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)&#10;                .build()&#10;            val at = AudioTrack.Builder()&#10;                .setAudioAttributes(attrs)&#10;                .setAudioFormat(format)&#10;                .setTransferMode(AudioTrack.MODE_STATIC)&#10;                .setBufferSizeInBytes(buffer.size * 2)&#10;                .build()&#10;            at.write(buffer, 0, buffer.size)&#10;            // loop forever&#10;            at.setLoopPoints(0, buffer.size, -1)&#10;            at&#10;        } catch (t: Throwable) {&#10;            Log.w(&quot;Tuner&quot;, &quot;AudioTrack create failed&quot;, t)&#10;            null&#10;        }&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {&#10;        Text(&quot;튜너 (기준음 재생)&quot;, fontWeight = FontWeight.Bold, fontSize = 22.sp)&#10;        Spacer(Modifier.height(16.dp))&#10;        // selection chips&#10;        FlowRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            strings.forEach { pair -&gt;&#10;                FilterChip(&#10;                    selected = selected == pair,&#10;                    onClick = { selected = pair },&#10;                    label = { Text(pair.first) }&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(24.dp))&#10;        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            Button(onClick = {&#10;                stop()&#10;                val newTrack = createLoopingTone(selected.second)&#10;                newTrack?.play()&#10;                track = newTrack&#10;                isPlaying = newTrack != null&#10;            }) {&#10;                Icon(Icons.Filled.PlayArrow, contentDescription = null)&#10;                Spacer(Modifier.width(6.dp))&#10;                Text(&quot;재생&quot;)&#10;            }&#10;            OutlinedButton(onClick = { stop() }) {&#10;                Icon(Icons.Filled.Pause, contentDescription = null)&#10;                Spacer(Modifier.width(6.dp))&#10;                Text(&quot;정지&quot;)&#10;            }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;        if (isPlaying) Text(&quot;재생 중: ${selected.first}&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.sweetapps.pocketchord&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.*&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import android.graphics.Color as AndroidColor&#10;import androidx.core.view.WindowCompat&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import com.sweetapps.pocketchord.ui.theme.PocketChordTheme&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.isFinite&#10;import androidx.lifecycle.lifecycleScope&#10;import android.net.Uri&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.compose.foundation.layout.FlowRow&#10;import android.media.ToneGenerator&#10;import android.media.AudioManager&#10;import kotlinx.coroutines.delay&#10;import android.media.AudioTrack&#10;import android.media.AudioAttributes&#10;import android.media.AudioFormat&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        // Ensure status bar background is white and icons are dark for readability at runtime&#10;        // Use WindowCompat/WindowInsetsControllerCompat for backward-compatible control&#10;        window.statusBarColor = AndroidColor.WHITE&#10;        val controller = WindowCompat.getInsetsController(window, window.decorView)&#10;        controller.isAppearanceLightStatusBars = true&#10;        // Optionally make navigation bar light as well&#10;        try {&#10;            controller.isAppearanceLightNavigationBars = true&#10;            window.navigationBarColor = AndroidColor.WHITE&#10;        } catch (_: Exception) {&#10;            // ignore on older platforms where this may not be supported&#10;        }&#10;        setContent {&#10;            PocketChordTheme {&#10;                val navController = rememberNavController()&#10;                Scaffold(&#10;                    bottomBar = { BottomNavigationBar(navController) },&#10;                    containerColor = Color.White&#10;                ) { innerPadding -&gt;&#10;                    NavHost(&#10;                        navController = navController,&#10;                        startDestination = &quot;home&quot;,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    ) {&#10;                        composable(&quot;home&quot;) {&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: home&quot;)&#10;                            MainScreen(navController)&#10;                        }&#10;                        composable(&quot;metronome&quot;) { com.sweetapps.pocketchord.ui.screens.MetronomeProScreen() }&#10;                        composable(&quot;tuner&quot;) { com.sweetapps.pocketchord.ui.screens.GuitarTunerScreen() }&#10;                        composable(&quot;search&quot;) {&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: search&quot;)&#10;                            SearchResultScreen()&#10;                        }&#10;                        composable(&quot;search_chord&quot;) {&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: search_chord&quot;)&#10;                            SearchChordScreen()&#10;                        }&#10;                        // Declare argument type explicitly; we'll decode on read&#10;                        composable(&#10;                            route = &quot;chord_list/{root}&quot;,&#10;                            arguments = listOf(navArgument(&quot;root&quot;) { type = NavType.StringType })&#10;                        ) { backStackEntry -&gt;&#10;                            val encoded = backStackEntry.arguments?.getString(&quot;root&quot;)&#10;                            val root = encoded?.let { Uri.decode(it) } ?: &quot;C&quot;&#10;                            Log.d(&quot;NavDebug&quot;, &quot;Entered route: chord_list/$root (encoded=$encoded)&quot;)&#10;                            ChordListScreen(navController = navController, root = root, onBack = { navController.popBackStack() })&#10;                        }&#10;                        // Optional settings screen remains, but without any seeding controls&#10;                        composable(&quot;settings&quot;) { BasicSettingsScreen() }&#10;                     }&#10;                 }&#10;             }&#10;         }&#10;&#10;        // On-app-update reseed only&#10;        lifecycleScope.launchWhenCreated {&#10;             try { com.sweetapps.pocketchord.data.ensureOrReseedOnAppUpdate(this@MainActivity) } catch (_: Exception) {}&#10;         }&#10;     }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(navController: NavHostController) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 24.dp)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;        TopBar()&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        Text(&#10;            text = &quot;코드를 선택하세요&quot;,&#10;            fontSize = 28.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color(0xFF31455A)&#10;        )&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        ChordGrid(navController)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TopBar() {&#10;    Row(verticalAlignment = Alignment.CenterVertically) {&#10;        Icon(&#10;            painter = painterResource(id = android.R.drawable.ic_media_play), // 임시 아이콘&#10;            contentDescription = null,&#10;            tint = Color(0xFF31455A),&#10;            modifier = Modifier.size(28.dp)&#10;        )&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;        Text(&#10;            text = &quot;PocketChord&quot;,&#10;            fontWeight = FontWeight.Bold,&#10;            fontSize = 22.sp,&#10;            color = Color(0xFF31455A)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChordGrid(navController: NavHostController) {&#10;    val chords = listOf(&#10;        &quot;C&quot;, &quot;C#-Db&quot;, &quot;D&quot;, &quot;D#-Eb&quot;,&#10;        &quot;E&quot;, &quot;F&quot;, &quot;F#-Gb&quot;, &quot;G&quot;,&#10;        &quot;G#-Ab&quot;, &quot;A&quot;, &quot;A#-Bb&quot;, &quot;B&quot;&#10;    )&#10;&#10;    // Map display names to root keys used in JSON&#10;    fun getRoot(displayName: String): String {&#10;        return when (displayName) {&#10;            &quot;C#-Db&quot; -&gt; &quot;C#&quot;&#10;            &quot;D#-Eb&quot; -&gt; &quot;D#&quot;&#10;            &quot;F#-Gb&quot; -&gt; &quot;F#&quot;&#10;            &quot;G#-Ab&quot; -&gt; &quot;G#&quot;&#10;            &quot;A#-Bb&quot; -&gt; &quot;A#&quot;&#10;            else -&gt; displayName&#10;        }&#10;    }&#10;&#10;    Column {&#10;        chords.chunked(3).forEach { rowList -&gt;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                rowList.forEach { chord -&gt;&#10;                    ChordButton(&#10;                        chord = chord,&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .clickable {&#10;                                val root = getRoot(chord)&#10;                                // encode to keep special characters (e.g., '#') safe in route path&#10;                                val route = &quot;chord_list/${Uri.encode(root)}&quot;&#10;                                Log.d(&quot;NavDebug&quot;, &quot;Click: navigating to ${route} from grid (chord=${chord}, root=${root})&quot;)&#10;                                navController.navigate(route)&#10;                            }&#10;                    )&#10;                }&#10;                // fill remaining columns with spacers if row has less than 3 items&#10;                if (rowList.size &lt; 3) {&#10;                    repeat(3 - rowList.size) { Spacer(modifier = Modifier.weight(1f)) }&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(20.dp))&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChordButton(chord: String, modifier: Modifier = Modifier) {&#10;    Box(&#10;        modifier = modifier&#10;            .aspectRatio(1f)&#10;            .background(Color.White, RoundedCornerShape(20.dp))&#10;            .padding(8.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = chord,&#10;            fontWeight = FontWeight.Bold,&#10;            fontSize = 22.sp,&#10;            color = Color(0xFF31455A)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BottomNavigationBar(navController: NavHostController) {&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;    NavigationBar(containerColor = Color.Transparent) {&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.MusicNote, contentDescription = &quot;코드&quot;) },&#10;            label = { Text(&quot;코드&quot;) },&#10;            selected = currentRoute == &quot;home&quot;,&#10;            onClick = { navController.navigate(&quot;home&quot;) }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Alarm, contentDescription = &quot;메트로놈&quot;) },&#10;            label = { Text(&quot;메트로놈&quot;) },&#10;            selected = currentRoute == &quot;metronome&quot;,&#10;            onClick = { navController.navigate(&quot;metronome&quot;) }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Equalizer, contentDescription = &quot;튜너&quot;) },&#10;            label = { Text(&quot;튜너&quot;) },&#10;            selected = currentRoute == &quot;tuner&quot;,&#10;            onClick = { navController.navigate(&quot;tuner&quot;) }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Star, contentDescription = &quot;즐겨찾기&quot;) },&#10;            label = { Text(&quot;즐겨찾기&quot;) },&#10;            selected = currentRoute == &quot;favorites&quot;, // 아직 미구현&#10;            onClick = { /* TODO: 즐겨찾기 구현 */ }&#10;        )&#10;        NavigationBarItem(&#10;            icon = { Icon(Icons.Filled.Settings, contentDescription = &quot;설정&quot;) },&#10;            label = { Text(&quot;설정&quot;) },&#10;            selected = currentRoute == &quot;settings&quot;,&#10;            onClick = { navController.navigate(&quot;settings&quot;) }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SearchResultScreen() {&#10;    val chordName = &quot;Cmaj7&quot;&#10;    val tags = listOf(&quot;C&quot;, &quot;Major 7&quot;, &quot;b5&quot;)&#10;    val codeCards = listOf(&#10;        FretDiagramData(&quot;TYARRRI&quot;, listOf(1, 3, 5, 7, 8, 0), fingers = listOf(0,2,3,0,1,0)),&#10;        FretDiagramData(&quot;AOTTTOURAL&quot;, listOf(2, 4, 6, 8, 10, 0), fingers = listOf(0,1,3,4,0,0))&#10;    )&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;            .padding(horizontal = 16.dp)&#10;    ) {&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                contentDescription = &quot;뒤로가기&quot;,&#10;                tint = Color(0xFF31455A),&#10;                modifier = Modifier.size(28.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(&#10;                text = &quot;검색 결과: $chordName&quot;,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 20.sp,&#10;                color = Color(0xFF31455A)&#10;            )&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            tags.forEach {&#10;                AssistChip(&#10;                    onClick = {},&#10;                    label = { Text(it, color = Color(0xFF31455A), fontWeight = FontWeight.Bold) },&#10;                    colors = AssistChipDefaults.assistChipColors(&#10;                        containerColor = Color(0xFFE3F0FF)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            // 코드 카드 UI는 제거됨. 간단히 코드 이름과 다이어그램 링크(예시)를 나열합니다.&#10;            codeCards.forEach { data -&gt;&#10;                Row(modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp), verticalAlignment = Alignment.CenterVertically) {&#10;                    Text(text = data.name, fontWeight = FontWeight.Bold, fontSize = 16.sp, modifier = Modifier.weight(1f))&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    // 간단한 소형 다이어그램을 우측에 표시&#10;                    FretDiagramImage()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SearchChordScreen() {&#10;    val types = listOf(&quot;Major&quot;, &quot;minor&quot;, &quot;dim&quot;, &quot;aug&quot;)&#10;    val tensions = listOf(&quot;7&quot;, &quot;M7&quot;, &quot;6&quot;, &quot;sus4&quot;, &quot;9&quot;, &quot;11&quot;, &quot;13&quot;)&#10;    val options = listOf(&quot;add9&quot;, &quot;b5&quot;, &quot;#5&quot;, &quot;b9&quot;)&#10;    val selectedRoot = &quot;C&quot;&#10;    val selectedType = &quot;Major&quot;&#10;    val selectedTension = &quot;M7&quot;&#10;    val selectedOptions = listOf(&quot;add9&quot;)&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;    ) {&#10;        // 상단 바&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth().padding(top = 16.dp, bottom = 8.dp, start = 8.dp, end = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = { /* TODO: 뒤로가기 */ }) {&#10;                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;뒤로가기&quot;, tint = Color(0xFF31455A))&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Text(&quot;코드 검색&quot;, fontWeight = FontWeight.Bold, fontSize = 18.sp, color = Color(0xFF31455A))&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Text(&quot;Reset&quot;, color = Color(0xFF00C6A2), fontWeight = FontWeight.Bold, modifier = Modifier.clickable { /* TODO: 리셋 */ })&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 코드명 및 설명&#10;        Column(modifier = Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {&#10;            Text(&quot;Cmaj7(add9)&quot;, fontWeight = FontWeight.Bold, fontSize = 32.sp, color = Color(0xFF31455A))&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&quot;아래 버튼을 눌러 코드를 조합해 보세요.&quot;, fontSize = 16.sp, color = Color(0xFF8CA0B3))&#10;        }&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;        // 루트 노트&#10;        SectionTitle(&quot;루트 노트 (Root Note)&quot;)&#10;        OutlinedButton(&#10;            onClick = {},&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = ButtonDefaults.outlinedButtonColors(containerColor = Color(0xFF00C6A2), contentColor = Color.White),&#10;            modifier = Modifier.fillMaxWidth().height(48.dp).padding(vertical = 8.dp, horizontal = 8.dp)&#10;        ) {&#10;            Text(selectedRoot, fontWeight = FontWeight.Bold, fontSize = 20.sp)&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 타입&#10;        SectionTitle(&quot;타입 (Type)&quot;)&#10;        Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            types.forEach {&#10;                OutlinedButton(&#10;                    onClick = {},&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        containerColor = if (it == selectedType) Color(0xFF00C6A2) else Color.White,&#10;                        contentColor = if (it == selectedType) Color.White else Color(0xFF31455A)&#10;                    ),&#10;                    modifier = Modifier.weight(1f).height(40.dp)&#10;                ) {&#10;                    Text(it, fontWeight = FontWeight.Bold)&#10;                }&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 텐션&#10;        SectionTitle(&quot;텐션 (Tensions)&quot;)&#10;        Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            tensions.forEach {&#10;                OutlinedButton(&#10;                    onClick = {},&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        containerColor = if (it == selectedTension) Color(0xFF00C6A2) else Color.White,&#10;                        contentColor = if (it == selectedTension) Color.White else Color(0xFF31455A)&#10;                    ),&#10;                    modifier = Modifier.weight(1f).height(40.dp)&#10;                ) {&#10;                    Text(it, fontWeight = FontWeight.Bold)&#10;                }&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        // 추가 옵션&#10;        SectionTitle(&quot;추가 옵션 (Options)&quot;)&#10;        Row(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            options.forEach {&#10;                OutlinedButton(&#10;                    onClick = {},&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = ButtonDefaults.outlinedButtonColors(&#10;                        containerColor = if (selectedOptions.contains(it)) Color(0xFF00C6A2) else Color.White,&#10;                        contentColor = if (selectedOptions.contains(it)) Color.White else Color(0xFF31455A)&#10;                    ),&#10;                    modifier = Modifier.weight(1f).height(40.dp)&#10;                ) {&#10;                    Text(it, fontWeight = FontWeight.Bold)&#10;                }&#10;            }&#10;        }&#10;        Spacer(modifier = Modifier.weight(1f))&#10;        // 하단 코드 찾기 버튼&#10;        Box(modifier = Modifier.fillMaxWidth().padding(16.dp), contentAlignment = Alignment.Center) {&#10;            Button(&#10;                onClick = { /* TODO: 코드 찾기 */ },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFFFA800)),&#10;                modifier = Modifier.fillMaxWidth().height(56.dp)&#10;            ) {&#10;                Icon(Icons.Filled.Search, contentDescription = null, tint = Color.White)&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&quot;코드 찾기&quot;, fontWeight = FontWeight.Bold, fontSize = 20.sp, color = Color.White)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SectionTitle(title: String) {&#10;    Text(title, fontWeight = FontWeight.Bold, fontSize = 16.sp, color = Color(0xFF31455A), modifier = Modifier.padding(start = 8.dp, bottom = 8.dp))&#10;}&#10;&#10;// 코드 다이어그램 데이터 예시&#10;// positions: stringCount 길이, -1=뮤트, 0=open, &gt;0=프렛번호&#10;// fingers: 동일 길이의 리스트, 0=표시안함, &gt;0=핑거링 숫자&#10;data class FretDiagramData(val name: String, val positions: List&lt;Int&gt;, val fingers: List&lt;Int&gt;? = null)&#10;&#10;// helper: parse CSV like &quot;-1,3,2,0,1,0&quot; into internal positions List&lt;Int&gt; index0=lowest string&#10;fun parseCsvToPositions(csv: String): List&lt;Int&gt; {&#10;    // Parse CSV into ints and return as-is. Storage order in DB/seed is 6→1 and UI expects the same.&#10;    return csv.split(&quot;,&quot;).mapNotNull { it.trim().toIntOrNull() }&#10;}&#10;&#10;// helper: parse barresJson (seed/DB) into ExplicitBarre list&#10;fun parseBarresJson(json: String?): List&lt;ExplicitBarre&gt;? {&#10;    if (json.isNullOrBlank()) return null&#10;    return try {&#10;        val arr = org.json.JSONArray(json)&#10;        val list = mutableListOf&lt;ExplicitBarre&gt;()&#10;        for (i in 0 until arr.length()) {&#10;            val o = arr.getJSONObject(i)&#10;            val fret = o.optInt(&quot;fret&quot;, 0)&#10;            val finger = o.optInt(&quot;finger&quot;, 0)&#10;            var fromS = o.optInt(&quot;fromString&quot;, 0)&#10;            var toS = o.optInt(&quot;toString&quot;, 0)&#10;            if (fret &gt; 0 &amp;&amp; finger &gt; 0 &amp;&amp; fromS in 1..6 &amp;&amp; toS in 1..6) {&#10;                if (fromS &gt; toS) { val tmp = fromS; fromS = toS; toS = tmp }&#10;                list.add(ExplicitBarre(fret, finger, fromS, toS))&#10;            }&#10;        }&#10;        if (list.isEmpty()) null else list&#10;    } catch (_: Throwable) { null }&#10;}&#10;&#10;// Build grouped sections for a given root according to requested order&#10;private data class ChordSection(val title: String, val items: List&lt;com.sweetapps.pocketchord.data.ChordWithVariants&gt;)&#10;private fun buildChordSectionsForRoot(root: String, all: List&lt;com.sweetapps.pocketchord.data.ChordWithVariants&gt;): List&lt;ChordSection&gt; {&#10;    // Templates expressed for root C; replace leading 'C' with the actual root&#10;    val groups = listOf(&#10;        &quot;Major&quot; to listOf(&quot;C&quot;, &quot;Cadd9&quot;, &quot;CM7&quot;, &quot;CM7(9)&quot;, &quot;C6&quot;, &quot;C6(9)&quot;),&#10;        &quot;minor&quot; to listOf(&quot;Cm&quot;, &quot;Cm7&quot;, &quot;Cm7(9)&quot;, &quot;Cm7(11)&quot;, &quot;Cm6&quot;, &quot;CmM7&quot;, &quot;Cm7(b5)&quot;, &quot;Cdim7&quot;),&#10;        &quot;7th&quot; to listOf(&quot;C7&quot;, &quot;C7(9)&quot;, &quot;C7(13)&quot;, &quot;C7(b5)&quot;, &quot;Csus4&quot;, &quot;C7sus4&quot;, &quot;Caug&quot;, &quot;C7aug&quot;)&#10;    )&#10;    fun toName(template: String): String = if (template.startsWith(&quot;C&quot;)) root + template.removePrefix(&quot;C&quot;) else template&#10;    val byName = all.associateBy { it.chord.name }&#10;    val used = mutableSetOf&lt;Long&gt;()&#10;    val sections = mutableListOf&lt;ChordSection&gt;()&#10;    for ((title, templates) in groups) {&#10;        val names = templates.map(::toName)&#10;        val items = names.mapNotNull { nm -&gt;&#10;            val m = byName[nm]&#10;            if (m != null) {&#10;                used.add(m.chord.id); m&#10;            } else null&#10;        }&#10;        if (items.isNotEmpty()) sections.add(ChordSection(title, items))&#10;    }&#10;    // Remaining chords not covered above → 기타(이름순)&#10;    val others = all.filter { used.contains(it.chord.id).not() }.sortedBy { it.chord.name }&#10;    if (others.isNotEmpty()) sections.add(ChordSection(&quot;기타&quot;, others))&#10;    return sections&#10;}&#10;&#10;@Composable&#10;fun ChordListScreen(&#10;    navController: NavHostController,&#10;    root: String,&#10;    onBack: () -&gt; Unit = {},&#10;    uiParams: DiagramUiParams = defaultDiagramUiParams()&#10;) {&#10;    val context = LocalContext.current&#10;    val db = com.sweetapps.pocketchord.data.AppDatabase.getInstance(context)&#10;    val chordFlow = db.chordDao().getChordsByRoot(root)&#10;    val chordWithVariants by chordFlow.collectAsState(initial = emptyList())&#10;    var isSeeding by remember { mutableStateOf(false) }&#10;&#10;    val perRootAsset = remember(root) { com.sweetapps.pocketchord.data.seedAssetFileNameForRoot(root) }&#10;&#10;    // ensure missing variants for this root (insert-only)&#10;    LaunchedEffect(root) {&#10;        try {&#10;            isSeeding = true&#10;            // 1) per-root 파일 우선 시딩 (프록시 형식 지원)&#10;            com.sweetapps.pocketchord.data.ensureChordsForRoot(context, root, perRootAsset)&#10;            // 2) 안전 폴백: 통합 파일에서도 시딩 (중복은 내부에서 방지)&#10;            com.sweetapps.pocketchord.data.ensureChordsForRoot(context, root)&#10;        } catch (t: Throwable) {&#10;            android.util.Log.w(&quot;ChordListScreen&quot;, &quot;ensureChordsForRoot failed&quot;, t)&#10;        } finally {&#10;            isSeeding = false&#10;        }&#10;    }&#10;&#10;    // 필터 상태: 단일 선택, null이면 전체 표시&#10;    var selectedFilter by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val availableFilters = listOf(&quot;Major&quot;, &quot;minor&quot;, &quot;7th&quot;)&#10;&#10;    // 섹션 구성 및 필터 적용&#10;    val allSections = remember(chordWithVariants, root) { buildChordSectionsForRoot(root, chordWithVariants) }&#10;    val sectionsToShow = remember(allSections, selectedFilter) {&#10;        if (selectedFilter == null) allSections else allSections.filter { it.title == selectedFilter }&#10;    }&#10;&#10;    Column(modifier = Modifier&#10;        .fillMaxSize()&#10;        .background(Color.White)&#10;    ) {&#10;        if (isSeeding) {&#10;            // simple loader overlay&#10;            Box(modifier = Modifier.fillMaxWidth().padding(12.dp), contentAlignment = Alignment.Center) {&#10;                CircularProgressIndicator()&#10;            }&#10;        }&#10;        // Top app bar with back button&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .background(Color.White)&#10;                .padding(start = 12.dp, top = 8.dp, bottom = 8.dp, end = 12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = { onBack() }) {&#10;                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = &quot;뒤로가기&quot;, tint = Color(0xFF31455A))&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(text = &quot;$root 코드&quot;, fontWeight = FontWeight.Bold, fontSize = 20.sp, color = Color(0xFF31455A))&#10;        }&#10;        // visual separation between top title and content — darker gray for better contrast&#10;        HorizontalDivider(color = Color(0xFFBDBDBD), thickness = 1.dp)&#10;&#10;        // 필터 칩(단일 선택 / 토글 해제)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .horizontalScroll(rememberScrollState())&#10;                .padding(start = 12.dp, end = 12.dp, top = 8.dp)&#10;        ) {&#10;            availableFilters.forEach { f -&gt;&#10;                val selected = selectedFilter == f&#10;                FilterChip(&#10;                    selected = selected,&#10;                    onClick = { selectedFilter = if (selected) null else f },&#10;                    label = {&#10;                        Text(&#10;                            text = f,&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                    },&#10;                    trailingIcon = if (selected) {&#10;                        { Icon(Icons.Filled.Close, contentDescription = &quot;해제&quot;, tint = Color.White) }&#10;                    } else null,&#10;                    shape = RoundedCornerShape(22.dp),&#10;                    border = null,&#10;                    colors = FilterChipDefaults.filterChipColors(&#10;                        containerColor = Color(0xFFF1F3F4),&#10;                        labelColor = Color(0xFF1F1F1F),&#10;                        selectedContainerColor = Color(0xFF1F1F1F),&#10;                        selectedLabelColor = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .height(40.dp)&#10;                        .padding(end = 10.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        // 총 개수(필터 적용 반영)&#10;        val totalVariants = sectionsToShow.sumOf { section -&gt; section.items.sumOf { it.variants.size } }&#10;        Text(text = &quot;총 ${totalVariants}개&quot;, fontWeight = FontWeight.Bold, fontSize = 16.sp, modifier = Modifier.padding(start = 16.dp))&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // 섹션별 리스트 (필터 반영)&#10;        LazyColumn(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentPadding = PaddingValues(vertical = 24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(DEFAULT_LIST_ITEM_SPACING_DP)&#10;        ) {&#10;            sectionsToShow.forEach { section -&gt;&#10;                item(key = &quot;header_${section.title}&quot;) {&#10;                    Text(&#10;                        text = section.title,&#10;                        fontWeight = FontWeight.ExtraBold,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF31455A),&#10;                        modifier = Modifier.padding(start = 16.dp, bottom = 6.dp, top = 8.dp)&#10;                    )&#10;                }&#10;                // Show every variant as an individual row so chords with multiple shapes (e.g., C) appear multiple times&#10;                items(&#10;                    items = section.items.flatMap { cwv -&gt; cwv.variants.map { v -&gt; cwv to v } },&#10;                    key = { pair -&gt; pair.second.id }&#10;                ) { pair -&gt;&#10;                    val cwv = pair.first&#10;                    val variant = pair.second&#10;                    val chordName = cwv.chord.name&#10;                    val positions = variant.positionsCsv.let { parseCsvToPositions(it) }&#10;                    val fingers = variant.fingersCsv?.let { parseCsvToPositions(it) } ?: List(6) { 0 }&#10;                    // debug log&#10;                    try {&#10;                        Log.d(&quot;ChordDiag&quot;, &quot;chord=${chordName} csvPositions=${variant.positionsCsv} parsedPositions=${positions} csvFingers=${variant.fingersCsv} parsedFingers=${fingers}&quot;)&#10;                    } catch (_: Exception) {}&#10;&#10;                    val desiredDiagramWidth = uiParams.diagramMaxWidthDp ?: 220.dp&#10;                    val diagramHeightForList = uiParams.diagramHeightDp ?: uiParams.diagramMinHeightDp&#10;                    val itemHeight = maxOf(uiParams.nameBoxSizeDp, diagramHeightForList)&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(itemHeight)&#10;                            .padding(horizontal = 12.dp, vertical = 8.dp),&#10;                        verticalAlignment = Alignment.Top&#10;                    ) {&#10;                        if (uiParams.diagramAnchor == DiagramAnchor.Left) {&#10;                            Box(modifier = Modifier.width(desiredDiagramWidth).height(diagramHeightForList)) {&#10;                                val explicitBarres = parseBarresJson(variant.barresJson)&#10;                                FretboardDiagramOnly(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    uiParams = uiParams,&#10;                                    positions = positions,&#10;                                    fingers = fingers,&#10;                                    firstFretIsNut = variant.firstFretIsNut,&#10;                                    invertStrings = false,&#10;                                    explicitBarres = explicitBarres&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.width(16.dp))&#10;                            Box(modifier = Modifier.size(uiParams.nameBoxSizeDp).background(DEFAULT_NAME_BOX_COLOR, shape = RoundedCornerShape(8.dp)), contentAlignment = Alignment.Center) {&#10;                                val chordFontSize = (uiParams.nameBoxSizeDp.value * uiParams.nameBoxFontScale).sp&#10;                                Text(text = chordName, color = Color.White, fontWeight = FontWeight.Bold, fontSize = chordFontSize)&#10;                            }&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;                        } else {&#10;                            Box(modifier = Modifier.size(uiParams.nameBoxSizeDp).background(DEFAULT_NAME_BOX_COLOR, shape = RoundedCornerShape(8.dp)), contentAlignment = Alignment.Center) {&#10;                                val chordFontSize = (uiParams.nameBoxSizeDp.value * uiParams.nameBoxFontScale).sp&#10;                                Text(text = chordName, color = Color.White, fontWeight = FontWeight.Bold, fontSize = chordFontSize)&#10;                            }&#10;                            Spacer(modifier = Modifier.width(16.dp))&#10;                            Box(modifier = Modifier.width(desiredDiagramWidth).height(diagramHeightForList)) {&#10;                                val explicitBarres = parseBarresJson(variant.barresJson)&#10;                                FretboardDiagramOnly(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    uiParams = uiParams,&#10;                                    positions = positions,&#10;                                    fingers = fingers,&#10;                                    firstFretIsNut = variant.firstFretIsNut,&#10;                                    invertStrings = false,&#10;                                    explicitBarres = explicitBarres&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;         }&#10;     }&#10;}&#10;&#10;@Composable&#10;fun FretboardCard(&#10;    chordName: String,&#10;    modifier: Modifier = Modifier,&#10;    uiParams: DiagramUiParams = defaultDiagramUiParams(), // centralized UI params&#10;    fretLabelProvider: ((Int) -&gt; String?)? = null&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp, horizontal = 4.dp), // 카드 외부 여백 약간 증가&#10;        shape = RoundedCornerShape(6.dp), // 더 둥글게&#10;        colors = CardDefaults.cardColors(containerColor = DEFAULT_CARD_BACKGROUND_COLOR),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)&#10;    ) {&#10;        // 카드 높이에 따라 다이어그램 크기를 계산하려면 BoxWithConstraints를 사용&#10;        BoxWithConstraints(modifier = Modifier.fillMaxWidth()) {&#10;            // BoxWithConstraints 범위에서 카드/다이어그램 크기 계산&#10;            val measuredCardHeight = this.maxHeight&#10;            val defaultCardHeight = 140.dp&#10;            // Use uiParams.cardHeightDp as authoritative when provided so Preview and runtime compute identically&#10;            val effectiveCardHeight = uiParams.cardHeightDp ?: if (measuredCardHeight.isFinite) measuredCardHeight else defaultCardHeight&#10;            // allow fixed diagram height via uiParams; otherwise derive from card height but respect min height&#10;            val diagramHeight = uiParams.diagramHeightDp ?: (effectiveCardHeight - 20.dp).coerceAtLeast(uiParams.diagramMinHeightDp)&#10;&#10;            // 카드 내부 상단에 여백을 위한 Spacer 추가&#10;            Column(modifier = Modifier.fillMaxWidth()) {&#10;                Spacer(modifier = Modifier.height(5.dp))&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(effectiveCardHeight)&#10;                        .padding(start = 8.dp, top = 8.dp, end = 0.dp, bottom = 8.dp),&#10;                     verticalAlignment = Alignment.Top&#10;                  ) {&#10;                    // collect sample DB-style positions &amp; fingers&#10;                    val dbPositionsForC = mapOf(1 to 0, 2 to 1, 3 to 0, 4 to 2, 5 to 3, 6 to -1)&#10;                    val dbFingersForC = mapOf(1 to 0, 2 to 1, 3 to 0, 4 to 2, 5 to 3, 6 to 0)&#10;                    val positionsForC = dbMapToInternalPositions(dbPositionsForC, stringCount = 6, defaultFret = -1)&#10;                    val fingersForC = dbMapToInternalPositions(dbFingersForC, stringCount = 6, defaultFret = 0)&#10;&#10;                    // reserved space used to compute total inner width (text area + gap). Do not include Row padding here.&#10;                    val textAreaWidth = 32.dp&#10;                    val gapBetween = 8.dp&#10;                    val reserved = textAreaWidth + gapBetween&#10;&#10;                    // compute desired (diagram) width from height-based calculation and configured max&#10;                    val heightBasedWidth = measuredCardHeight * (140f / 96f)&#10;                    val desiredWidth = uiParams.diagramMaxWidthDp?.let { mw -&gt; if (heightBasedWidth &gt; mw) mw else heightBasedWidth } ?: heightBasedWidth&#10;&#10;                    // total inner width that contains text + gap + diagram + right inset&#10;                    val innerTotal = reserved + desiredWidth + uiParams.diagramRightInsetDp&#10;&#10;                    // Align the fixed-width inner row to the card's end so the trailing inset becomes the gap to the card edge&#10;                    Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.CenterEnd) {&#10;                        Row(modifier = Modifier.width(innerTotal).height(effectiveCardHeight), verticalAlignment = Alignment.Top) {&#10;                            // chord name (fixed width)&#10;                            Text(text = chordName, fontWeight = FontWeight.Bold, fontSize = 26.sp, color = Color.Black, modifier = Modifier.width(textAreaWidth).padding(start = 4.dp))&#10;                            Spacer(modifier = Modifier.width(gapBetween))&#10;                            Box(modifier = Modifier.width(desiredWidth).height(diagramHeight)) {&#10;                                if (chordName == &quot;C&quot;) {&#10;                                    FretboardDiagramOnly(modifier = Modifier.fillMaxSize(), uiParams = uiParams, positions = positionsForC, fingers = fingersForC, firstFretIsNut = true, fretLabelProvider = fretLabelProvider, invertStrings = false)&#10;                                } else {&#10;                                    // default empty/mute positions for non-sample chords in preview&#10;                                    val defaultPositions = List(6) { -1 }&#10;                                    val defaultFingers = List(6) { 0 }&#10;                                    FretboardDiagramOnly(modifier = Modifier.fillMaxSize(), uiParams = uiParams, positions = defaultPositions, fingers = defaultFingers, firstFretIsNut = true, invertStrings = false)&#10;                                }&#10;                            }&#10;                            Spacer(modifier = Modifier.width(uiParams.diagramRightInsetDp))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BasicSettingsScreen() {&#10;    // Minimal settings placeholder — removed manual seeding and toggles&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;        Text(text = &quot;설정&quot;, fontSize = 20.sp, fontWeight = FontWeight.Bold)&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;        Text(text = &quot;앱 업데이트 시 코드 데이터가 자동으로 동기화됩니다.&quot;)&#10;    }&#10;}&#10;&#10;// --- New screens ---&#10;@Composable&#10;fun MetronomeScreen() {&#10;    var bpm by remember { mutableStateOf(100f) }&#10;    var playing by remember { mutableStateOf(false) }&#10;    var beatInBar by remember { mutableStateOf(4) }&#10;    var currentBeat by remember { mutableStateOf(1) }&#10;&#10;    // Tone generator for click sounds&#10;    val toneGen = remember { ToneGenerator(AudioManager.STREAM_MUSIC, 80) }&#10;    DisposableEffect(Unit) {&#10;        onDispose { try { toneGen.release() } catch (_: Throwable) {} }&#10;    }&#10;&#10;    LaunchedEffect(playing, bpm, beatInBar) {&#10;        currentBeat = 1&#10;        if (playing) {&#10;            val intervalMs = (60_000f / bpm).toLong().coerceAtLeast(40L)&#10;            while (playing) {&#10;                // accent first beat&#10;                val tone = if (currentBeat == 1) ToneGenerator.TONE_PROP_BEEP2 else ToneGenerator.TONE_PROP_BEEP&#10;                try { toneGen.startTone(tone, 60) } catch (_: Throwable) {}&#10;                currentBeat = if (currentBeat &gt;= beatInBar) 1 else currentBeat + 1&#10;                delay(intervalMs)&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {&#10;        Text(&quot;메트로놈&quot;, fontWeight = FontWeight.Bold, fontSize = 22.sp)&#10;        Spacer(Modifier.height(16.dp))&#10;        // Beat indicators&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            repeat(beatInBar) { idx -&gt;&#10;                val active = playing &amp;&amp; (idx + 1) == currentBeat&#10;                Box(modifier = Modifier.size(18.dp).background(if (active) Color(0xFFFF6F00) else Color(0xFFB0BEC5), RoundedCornerShape(50)))&#10;            }&#10;        }&#10;        Spacer(Modifier.height(16.dp))&#10;        Text(&quot;BPM: ${bpm.toInt()}&quot;)&#10;        Slider(&#10;            value = bpm,&#10;            onValueChange = { bpm = it.coerceIn(40f, 240f) },&#10;            valueRange = 40f..240f&#10;        )&#10;        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            OutlinedButton(onClick = { bpm = (bpm - 1).coerceAtLeast(40f) }) { Text(&quot;-1&quot;) }&#10;            OutlinedButton(onClick = { bpm = (bpm + 1).coerceAtMost(240f) }) { Text(&quot;+1&quot;) }&#10;            OutlinedButton(onClick = { bpm = (bpm - 5).coerceAtLeast(40f) }) { Text(&quot;-5&quot;) }&#10;            OutlinedButton(onClick = { bpm = (bpm + 5).coerceAtMost(240f) }) { Text(&quot;+5&quot;) }&#10;        }&#10;        Spacer(Modifier.height(12.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&quot;박자 수: &quot;)&#10;            Row {&#10;                listOf(2,3,4,6).forEach { n -&gt;&#10;                    FilterChip(&#10;                        selected = beatInBar == n,&#10;                        onClick = { beatInBar = n; currentBeat = 1 },&#10;                        label = { Text(&quot;${n}&quot;) },&#10;                        modifier = Modifier.padding(horizontal = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        Spacer(Modifier.height(24.dp))&#10;        Button(onClick = { playing = !playing }, colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (playing) Color(0xFFD32F2F) else Color(0xFF00C853)&#10;        )) {&#10;            Icon(if (playing) Icons.Filled.Pause else Icons.Filled.PlayArrow, contentDescription = null)&#10;            Spacer(Modifier.width(6.dp))&#10;            Text(if (playing) &quot;정지&quot; else &quot;시작&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun TunerScreen() {&#10;    // Standard guitar open-string reference tones&#10;    val strings = listOf(&#10;        &quot;E(6) 82.41Hz&quot; to 82.41,&#10;        &quot;A(5) 110Hz&quot; to 110.0,&#10;        &quot;D(4) 146.83Hz&quot; to 146.83,&#10;        &quot;G(3) 196.00Hz&quot; to 196.0,&#10;        &quot;B(2) 246.94Hz&quot; to 246.94,&#10;        &quot;E(1) 329.63Hz&quot; to 329.63&#10;    )&#10;    var selected by remember { mutableStateOf(strings[5]) }&#10;    var track by remember { mutableStateOf&lt;AudioTrack?&gt;(null) }&#10;    var isPlaying by remember { mutableStateOf(false) }&#10;&#10;    fun stop() {&#10;        try { track?.stop() } catch (_: Throwable) {}&#10;        try { track?.release() } catch (_: Throwable) {}&#10;        track = null&#10;        isPlaying = false&#10;    }&#10;&#10;    DisposableEffect(Unit) { onDispose { stop() } }&#10;&#10;    fun createLoopingTone(freqHz: Double): AudioTrack? {&#10;        val sampleRate = 44_100&#10;        val durationSec = 1.0 // short but looped&#10;        val frameCount = (sampleRate * durationSec).toInt()&#10;        val buffer = ShortArray(frameCount) { i -&gt;&#10;            val t = i / sampleRate.toDouble()&#10;            val v = kotlin.math.sin(2.0 * Math.PI * freqHz * t)&#10;            (v * Short.MAX_VALUE).toInt().coerceIn(Short.MIN_VALUE.toInt(), Short.MAX_VALUE.toInt()).toShort()&#10;        }&#10;        return try {&#10;            val attrs = AudioAttributes.Builder()&#10;                .setUsage(AudioAttributes.USAGE_MEDIA)&#10;                .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)&#10;                .build()&#10;            val format = AudioFormat.Builder()&#10;                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)&#10;                .setSampleRate(sampleRate)&#10;                .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)&#10;                .build()&#10;            val at = AudioTrack.Builder()&#10;                .setAudioAttributes(attrs)&#10;                .setAudioFormat(format)&#10;                .setTransferMode(AudioTrack.MODE_STATIC)&#10;                .setBufferSizeInBytes(buffer.size * 2)&#10;                .build()&#10;            at.write(buffer, 0, buffer.size)&#10;            // loop forever&#10;            at.setLoopPoints(0, buffer.size, -1)&#10;            at&#10;        } catch (t: Throwable) {&#10;            Log.w(&quot;Tuner&quot;, &quot;AudioTrack create failed&quot;, t)&#10;            null&#10;        }&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {&#10;        Text(&quot;튜너 (기준음 재생)&quot;, fontWeight = FontWeight.Bold, fontSize = 22.sp)&#10;        Spacer(Modifier.height(16.dp))&#10;        // selection chips&#10;        FlowRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            strings.forEach { pair -&gt;&#10;                FilterChip(&#10;                    selected = selected == pair,&#10;                    onClick = { selected = pair },&#10;                    label = { Text(pair.first) }&#10;                )&#10;            }&#10;        }&#10;        Spacer(Modifier.height(24.dp))&#10;        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {&#10;            Button(onClick = {&#10;                stop()&#10;                val newTrack = createLoopingTone(selected.second)&#10;                newTrack?.play()&#10;                track = newTrack&#10;                isPlaying = newTrack != null&#10;            }) {&#10;                Icon(Icons.Filled.PlayArrow, contentDescription = null)&#10;                Spacer(Modifier.width(6.dp))&#10;                Text(&quot;재생&quot;)&#10;            }&#10;            OutlinedButton(onClick = { stop() }) {&#10;                Icon(Icons.Filled.Pause, contentDescription = null)&#10;                Spacer(Modifier.width(6.dp))&#10;                Text(&quot;정지&quot;)&#10;            }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;        if (isPlaying) Text(&quot;재생 중: ${selected.first}&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>